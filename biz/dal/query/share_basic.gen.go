// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"cloud-storage/biz/dal/entity"
)

func newShareBasic(db *gorm.DB, opts ...gen.DOOption) shareBasic {
	_shareBasic := shareBasic{}

	_shareBasic.shareBasicDo.UseDB(db, opts...)
	_shareBasic.shareBasicDo.UseModel(&entity.ShareBasic{})

	tableName := _shareBasic.shareBasicDo.TableName()
	_shareBasic.ALL = field.NewAsterisk(tableName)
	_shareBasic.ID = field.NewUint32(tableName, "id")
	_shareBasic.Identity = field.NewString(tableName, "identity")
	_shareBasic.UserIdentity = field.NewString(tableName, "user_identity")
	_shareBasic.RepositoryIdentity = field.NewString(tableName, "repository_identity")
	_shareBasic.UserRepositoryIdentity = field.NewString(tableName, "user_repository_identity")
	_shareBasic.ExpiredTime = field.NewInt32(tableName, "expired_time")
	_shareBasic.ClickNum = field.NewInt32(tableName, "click_num")
	_shareBasic.CreatedAt = field.NewTime(tableName, "created_at")
	_shareBasic.UpdatedAt = field.NewTime(tableName, "updated_at")
	_shareBasic.DeletedAt = field.NewField(tableName, "deleted_at")

	_shareBasic.fillFieldMap()

	return _shareBasic
}

type shareBasic struct {
	shareBasicDo

	ALL                    field.Asterisk
	ID                     field.Uint32
	Identity               field.String
	UserIdentity           field.String
	RepositoryIdentity     field.String // 公共池中的唯一标识
	UserRepositoryIdentity field.String // 用户池子中的唯一标识
	ExpiredTime            field.Int32  // 失效时间，单位秒, 【0-永不失效】
	ClickNum               field.Int32  // 点击次数
	CreatedAt              field.Time
	UpdatedAt              field.Time
	DeletedAt              field.Field

	fieldMap map[string]field.Expr
}

func (s shareBasic) Table(newTableName string) *shareBasic {
	s.shareBasicDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s shareBasic) As(alias string) *shareBasic {
	s.shareBasicDo.DO = *(s.shareBasicDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *shareBasic) updateTableName(table string) *shareBasic {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewUint32(table, "id")
	s.Identity = field.NewString(table, "identity")
	s.UserIdentity = field.NewString(table, "user_identity")
	s.RepositoryIdentity = field.NewString(table, "repository_identity")
	s.UserRepositoryIdentity = field.NewString(table, "user_repository_identity")
	s.ExpiredTime = field.NewInt32(table, "expired_time")
	s.ClickNum = field.NewInt32(table, "click_num")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")
	s.DeletedAt = field.NewField(table, "deleted_at")

	s.fillFieldMap()

	return s
}

func (s *shareBasic) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *shareBasic) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 10)
	s.fieldMap["id"] = s.ID
	s.fieldMap["identity"] = s.Identity
	s.fieldMap["user_identity"] = s.UserIdentity
	s.fieldMap["repository_identity"] = s.RepositoryIdentity
	s.fieldMap["user_repository_identity"] = s.UserRepositoryIdentity
	s.fieldMap["expired_time"] = s.ExpiredTime
	s.fieldMap["click_num"] = s.ClickNum
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
	s.fieldMap["deleted_at"] = s.DeletedAt
}

func (s shareBasic) clone(db *gorm.DB) shareBasic {
	s.shareBasicDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s shareBasic) replaceDB(db *gorm.DB) shareBasic {
	s.shareBasicDo.ReplaceDB(db)
	return s
}

type shareBasicDo struct{ gen.DO }

type IShareBasicDo interface {
	gen.SubQuery
	Debug() IShareBasicDo
	WithContext(ctx context.Context) IShareBasicDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IShareBasicDo
	WriteDB() IShareBasicDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IShareBasicDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IShareBasicDo
	Not(conds ...gen.Condition) IShareBasicDo
	Or(conds ...gen.Condition) IShareBasicDo
	Select(conds ...field.Expr) IShareBasicDo
	Where(conds ...gen.Condition) IShareBasicDo
	Order(conds ...field.Expr) IShareBasicDo
	Distinct(cols ...field.Expr) IShareBasicDo
	Omit(cols ...field.Expr) IShareBasicDo
	Join(table schema.Tabler, on ...field.Expr) IShareBasicDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IShareBasicDo
	RightJoin(table schema.Tabler, on ...field.Expr) IShareBasicDo
	Group(cols ...field.Expr) IShareBasicDo
	Having(conds ...gen.Condition) IShareBasicDo
	Limit(limit int) IShareBasicDo
	Offset(offset int) IShareBasicDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IShareBasicDo
	Unscoped() IShareBasicDo
	Create(values ...*entity.ShareBasic) error
	CreateInBatches(values []*entity.ShareBasic, batchSize int) error
	Save(values ...*entity.ShareBasic) error
	First() (*entity.ShareBasic, error)
	Take() (*entity.ShareBasic, error)
	Last() (*entity.ShareBasic, error)
	Find() ([]*entity.ShareBasic, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.ShareBasic, err error)
	FindInBatches(result *[]*entity.ShareBasic, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*entity.ShareBasic) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IShareBasicDo
	Assign(attrs ...field.AssignExpr) IShareBasicDo
	Joins(fields ...field.RelationField) IShareBasicDo
	Preload(fields ...field.RelationField) IShareBasicDo
	FirstOrInit() (*entity.ShareBasic, error)
	FirstOrCreate() (*entity.ShareBasic, error)
	FindByPage(offset int, limit int) (result []*entity.ShareBasic, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IShareBasicDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s shareBasicDo) Debug() IShareBasicDo {
	return s.withDO(s.DO.Debug())
}

func (s shareBasicDo) WithContext(ctx context.Context) IShareBasicDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s shareBasicDo) ReadDB() IShareBasicDo {
	return s.Clauses(dbresolver.Read)
}

func (s shareBasicDo) WriteDB() IShareBasicDo {
	return s.Clauses(dbresolver.Write)
}

func (s shareBasicDo) Session(config *gorm.Session) IShareBasicDo {
	return s.withDO(s.DO.Session(config))
}

func (s shareBasicDo) Clauses(conds ...clause.Expression) IShareBasicDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s shareBasicDo) Returning(value interface{}, columns ...string) IShareBasicDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s shareBasicDo) Not(conds ...gen.Condition) IShareBasicDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s shareBasicDo) Or(conds ...gen.Condition) IShareBasicDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s shareBasicDo) Select(conds ...field.Expr) IShareBasicDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s shareBasicDo) Where(conds ...gen.Condition) IShareBasicDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s shareBasicDo) Order(conds ...field.Expr) IShareBasicDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s shareBasicDo) Distinct(cols ...field.Expr) IShareBasicDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s shareBasicDo) Omit(cols ...field.Expr) IShareBasicDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s shareBasicDo) Join(table schema.Tabler, on ...field.Expr) IShareBasicDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s shareBasicDo) LeftJoin(table schema.Tabler, on ...field.Expr) IShareBasicDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s shareBasicDo) RightJoin(table schema.Tabler, on ...field.Expr) IShareBasicDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s shareBasicDo) Group(cols ...field.Expr) IShareBasicDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s shareBasicDo) Having(conds ...gen.Condition) IShareBasicDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s shareBasicDo) Limit(limit int) IShareBasicDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s shareBasicDo) Offset(offset int) IShareBasicDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s shareBasicDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IShareBasicDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s shareBasicDo) Unscoped() IShareBasicDo {
	return s.withDO(s.DO.Unscoped())
}

func (s shareBasicDo) Create(values ...*entity.ShareBasic) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s shareBasicDo) CreateInBatches(values []*entity.ShareBasic, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s shareBasicDo) Save(values ...*entity.ShareBasic) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s shareBasicDo) First() (*entity.ShareBasic, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ShareBasic), nil
	}
}

func (s shareBasicDo) Take() (*entity.ShareBasic, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ShareBasic), nil
	}
}

func (s shareBasicDo) Last() (*entity.ShareBasic, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ShareBasic), nil
	}
}

func (s shareBasicDo) Find() ([]*entity.ShareBasic, error) {
	result, err := s.DO.Find()
	return result.([]*entity.ShareBasic), err
}

func (s shareBasicDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.ShareBasic, err error) {
	buf := make([]*entity.ShareBasic, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s shareBasicDo) FindInBatches(result *[]*entity.ShareBasic, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s shareBasicDo) Attrs(attrs ...field.AssignExpr) IShareBasicDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s shareBasicDo) Assign(attrs ...field.AssignExpr) IShareBasicDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s shareBasicDo) Joins(fields ...field.RelationField) IShareBasicDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s shareBasicDo) Preload(fields ...field.RelationField) IShareBasicDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s shareBasicDo) FirstOrInit() (*entity.ShareBasic, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ShareBasic), nil
	}
}

func (s shareBasicDo) FirstOrCreate() (*entity.ShareBasic, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ShareBasic), nil
	}
}

func (s shareBasicDo) FindByPage(offset int, limit int) (result []*entity.ShareBasic, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s shareBasicDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s shareBasicDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s shareBasicDo) Delete(models ...*entity.ShareBasic) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *shareBasicDo) withDO(do gen.Dao) *shareBasicDo {
	s.DO = *do.(*gen.DO)
	return s
}
