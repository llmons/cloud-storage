// Code generated by hertz generator.

package file

import (
	"cloud-storage/biz/dal/entity"
	"cloud-storage/biz/dal/query"
	file "cloud-storage/biz/model/file"
	"context"
	"crypto/md5"
	"errors"
	"fmt"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/duke-git/lancet/v2/random"
	"gorm.io/gorm"
	"mime/multipart"
	"os"
	"path/filepath"
	"strconv"
)

var q = query.Q

// FileUpload .
// @router /file/upload [POST]
func FileUpload(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.FileUploadRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	fileHeader, err := c.FormFile("file")
	if err != nil {
		c.String(consts.StatusBadRequest, "file upload error: %v", err)
		return
	}

	// Check file if exists
	bytes := make([]byte, fileHeader.Size)
	openedFile, err := fileHeader.Open()
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to open file: %v", err)
		return
	}
	defer func(openedFile multipart.File) {
		err := openedFile.Close()
		if err != nil {
			c.String(consts.StatusInternalServerError, "failed to close file: %v", err)
		}
	}(openedFile)
	_, err = openedFile.Read(bytes)
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to read file: %v", err)
		return
	}
	hash := fmt.Sprintf("%x", md5.Sum(bytes))
	rp, err := q.RepositoryPool.Where(q.RepositoryPool.Hash.Eq(hash)).First()
	if err != nil && errors.Is(err, gorm.ErrRecordNotFound) {
		c.String(consts.StatusInternalServerError, "failed to query repository pool: %v", err)
		return
	}
	if rp != nil {
		c.String(consts.StatusBadRequest, "file already exists: %s", rp.Hash)
		return
	}

	// Save the file
	filename := filepath.Base(fileHeader.Filename)
	joinedPath := filepath.Join(os.TempDir(), "cloud_storage", filename)
	if err := os.MkdirAll(filepath.Dir(joinedPath), os.ModePerm); err != nil {
		c.String(consts.StatusInternalServerError, "failed to create directory: %v", err)
		return
	}
	if err := c.SaveUploadedFile(fileHeader, joinedPath); err != nil {
		c.String(consts.StatusInternalServerError, "failed to save file: %v", err)
		return
	}

	// Create repository pool record
	uuid, err := random.UUIdV4()
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to generate UUID: %v", err)
		return
	}
	rp = &entity.RepositoryPool{
		Identity: uuid,
		Hash:     hash,
		Name:     filename,
		Ext:      filepath.Ext(filename),
		Size:     int32(fileHeader.Size),
		Path:     joinedPath,
	}
	if err := q.RepositoryPool.Create(rp); err != nil {
		c.String(consts.StatusInternalServerError, "failed to create repository pool: %v", err)
		return
	}

	c.JSON(consts.StatusOK, &file.FileUploadReply{
		Identity: rp.Identity,
		Ext:      rp.Ext,
		Name:     rp.Name,
	})
}

// UserRepositorySave .
// @router /user/repository/save [POST]
func UserRepositorySave(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserRepositorySaveRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	uuid, err := random.UUIdV4()
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to generate UUID: %v", err)
		return
	}
	ur := entity.UserRepository{
		Identity:           uuid,
		UserIdentity:       "",
		ParentID:           int32(req.ParentId),
		RepositoryIdentity: req.RepositoryIdentity,
		Ext:                req.Ext,
		Name:               req.Name,
	}
	if err := q.UserRepository.Create(&ur); err != nil {
		c.String(consts.StatusInternalServerError, "failed to create repository: %v", err)
		return
	}

	c.JSON(consts.StatusOK, file.UserRepositorySaveReply{})
}

// UserFileList .
// @router /user/file/list [POST]
func UserFileList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFileListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	var uf []*file.UserFile
	size := req.Size
	if size <= 0 {
		size = 10 // Default size
	}
	page := req.Page
	if page <= 0 {
		page = 1 // Default page
	}
	offset := (page - 1) * size
	ID, err := strconv.Atoi(req.Identity)
	if err != nil {
		c.String(consts.StatusBadRequest, "invalid identity: %v", err)
		return
	}
	err = q.UserRepository.
		Select(q.UserRepository.ID, q.UserRepository.Identity, q.UserRepository.RepositoryIdentity, q.UserRepository.Ext,
			q.UserRepository.Name, q.RepositoryPool.Path, q.RepositoryPool.Size).
		Where(q.UserRepository.ParentID.Eq(int32(ID)), q.UserRepository.UserIdentity.Eq("")).
		LeftJoin(q.RepositoryPool, q.UserRepository.UserIdentity.EqCol(q.RepositoryPool.Identity)).
		Limit(int(size)).Offset(int(offset)).Scan(&uf)
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to query user repository: %v", err)
		return
	}

	count, err := q.UserRepository.Where(q.UserRepository.ParentID.Eq(int32(ID)), q.UserRepository.UserIdentity.Eq("")).Count()
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to count user repository: %v", err)
		return
	}

	c.JSON(consts.StatusOK, file.UserFileListReply{
		List:  uf,
		Count: count,
	})
}

// UserFolderList .
// @router /user/folder/list [POST]
func UserFolderList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFolderListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserFolderListReply)

	c.JSON(consts.StatusOK, resp)
}

// UserFileNameUpdate .
// @router /user/file/name/update [POST]
func UserFileNameUpdate(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFileNameUpdateRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	sub := q.UserRepository.
		Select(q.UserRepository.ParentID).
		Where(q.UserRepository.Identity.Eq(req.Identity))
	count, err := q.UserRepository.Where(q.UserRepository.Name.Eq(req.Name),
		q.UserRepository.Columns(q.UserRepository.ParentID).Eq(sub)).
		Count()
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to count user repository: %v", err)
		return
	}
	if count > 0 {
		c.String(consts.StatusBadRequest, "file name already exists in the same folder")
		return
	}

	_, err = q.UserRepository.Where(q.UserRepository.UserIdentity.Eq(req.Identity)).
		Update(q.UserRepository.Name, req.Name)
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to update user repository name: %v", err)
		return
	}

	c.JSON(consts.StatusOK, file.UserFileNameUpdateReply{})
}

// UserFolderCreate .
// @router /user/folder/create [POST]
func UserFolderCreate(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFolderCreateRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	count, err := q.UserRepository.Where(q.UserRepository.Name.Eq(req.Name),
		q.UserRepository.ParentID.Eq(int32(req.ParentId))).
		Count()
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to count user repository: %v", err)
		return
	}
	if count > 0 {
		c.String(consts.StatusBadRequest, "file name already exists in the same folder")
		return
	}

	uuid, err := random.UUIdV4()
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to generate UUID: %v", err)
		return
	}
	ur := entity.UserRepository{
		Identity:     uuid,
		UserIdentity: "",
		ParentID:     int32(req.ParentId),
		Name:         req.Name,
	}
	if err := q.UserRepository.Create(&ur); err != nil {
		c.String(consts.StatusInternalServerError, "failed to create repository: %v", err)
		return
	}

	c.JSON(consts.StatusOK, file.UserFolderCreateReply{
		Identity: uuid,
	})
}

// UserFileDelete .
// @router /user/file/delete [DELETE]
func UserFileDelete(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFileDeleteRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserFileDeleteReply)

	c.JSON(consts.StatusOK, resp)
}

// UserFileMove .
// @router /user/file/move [PUT]
func UserFileMove(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFileMoveRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserFileMoveReply)

	c.JSON(consts.StatusOK, resp)
}
