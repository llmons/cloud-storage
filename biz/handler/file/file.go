// Code generated by hertz generator.

package file

import (
	"cloud-storage/biz/dal/entity"
	"cloud-storage/biz/dal/query"
	"context"
	"crypto/md5"
	"errors"
	"fmt"
	"github.com/duke-git/lancet/v2/random"
	"gorm.io/gorm"
	"mime/multipart"
	"os"
	"path/filepath"

	file "cloud-storage/biz/model/file"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

var q = query.Q

// FileUpload .
// @router /file/upload [POST]
func FileUpload(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.FileUploadRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	fileHeader, err := c.FormFile("file")
	if err != nil {
		c.String(consts.StatusBadRequest, "file upload error: %v", err)
		return
	}

	// Check file if exists
	bytes := make([]byte, fileHeader.Size)
	openedFile, err := fileHeader.Open()
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to open file: %v", err)
		return
	}
	defer func(openedFile multipart.File) {
		err := openedFile.Close()
		if err != nil {
			c.String(consts.StatusInternalServerError, "failed to close file: %v", err)
		}
	}(openedFile)
	_, err = openedFile.Read(bytes)
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to read file: %v", err)
		return
	}
	hash := fmt.Sprintf("%x", md5.Sum(bytes))
	rp, err := q.RepositoryPool.Where(q.RepositoryPool.Hash.Eq(hash)).First()
	if err != nil && errors.Is(err, gorm.ErrRecordNotFound) {
		c.String(consts.StatusInternalServerError, "failed to query repository pool: %v", err)
		return
	}
	if rp != nil {
		c.String(consts.StatusBadRequest, "file already exists: %s", rp.Hash)
		return
	}

	// Save the file
	filename := filepath.Base(fileHeader.Filename)
	joinedPath := filepath.Join(os.TempDir(), "cloud_storage", filename)
	if err := os.MkdirAll(filepath.Dir(joinedPath), os.ModePerm); err != nil {
		c.String(consts.StatusInternalServerError, "failed to create directory: %v", err)
		return
	}
	if err := c.SaveUploadedFile(fileHeader, joinedPath); err != nil {
		c.String(consts.StatusInternalServerError, "failed to save file: %v", err)
		return
	}

	// Create repository pool record
	uuid, err := random.UUIdV4()
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to generate UUID: %v", err)
		return
	}
	rp = &entity.RepositoryPool{
		Identity: uuid,
		Hash:     hash,
		Name:     filename,
		Ext:      filepath.Ext(filename),
		Size:     int32(fileHeader.Size),
		Path:     joinedPath,
	}
	if err := q.RepositoryPool.Create(rp); err != nil {
		c.String(consts.StatusInternalServerError, "failed to create repository pool: %v", err)
		return
	}

	c.JSON(consts.StatusOK, &file.FileUploadReply{
		Identity: rp.Identity,
		Ext:      rp.Ext,
		Name:     rp.Name,
	})
}

// UserRepositorySave .
// @router /user/repository/save [POST]
func UserRepositorySave(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserRepositorySaveRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserRepositorySaveReply)

	c.JSON(consts.StatusOK, resp)
}

// UserFileList .
// @router /user/file/list [POST]
func UserFileList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFileListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserFileListReply)

	c.JSON(consts.StatusOK, resp)
}

// UserFolderList .
// @router /user/folder/list [POST]
func UserFolderList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFolderListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserFolderListReply)

	c.JSON(consts.StatusOK, resp)
}

// UserFileNameUpdate .
// @router /user/file/name/update [POST]
func UserFileNameUpdate(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFileNameUpdateRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserFileNameUpdateReply)

	c.JSON(consts.StatusOK, resp)
}

// UserFolderCreate .
// @router /user/folder/create [POST]
func UserFolderCreate(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFolderCreateRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserFolderCreateReply)

	c.JSON(consts.StatusOK, resp)
}

// UserFileDelete .
// @router /user/file/delete [DELETE]
func UserFileDelete(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFileDeleteRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserFileDeleteReply)

	c.JSON(consts.StatusOK, resp)
}

// UserFileMove .
// @router /user/file/move [PUT]
func UserFileMove(ctx context.Context, c *app.RequestContext) {
	var err error
	var req file.UserFileMoveRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(file.UserFileMoveReply)

	c.JSON(consts.StatusOK, resp)
}
